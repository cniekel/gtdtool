#!/usr/bin/python
# vim:ft=python

import os
from optparse import OptionParser
import logging
import re
from textwrap import wrap
import sys
import gtdpdfprinter

logging.basicConfig(level=logging.INFO)
actionmatcher = re.compile('^(?P<code>[@*.-])(?P<list>[a-zA-Z0-9]*)[ :](?P<what>.*)$')
lists = {}
gtd_dir = '~/gtd/'
actionlog = logging.getLogger('action')

from Cheetah.Template import Template
flowlog = logging.getLogger('programflow')

simpleTemplate = \
'''$actionlist
#for it in $actions
    $it.what [$it.project]
#end for
'''

import warnings
def nothing(*args):
    pass
warnings.showwarning = nothing

def printFile(fname):
    if sys.platform == 'win32':
        import win32api

        filename = 'gtdlist.pdf'
        win32api.ShellExecute ( 0, "print", filename, None, ".", 0)
    elif sys.platform == 'linux':
        print 'Can I just do lpr %s now?' % fname
    else:
        print 'printing not yet supported for your platform'
        print 'The pdf file is %s' % fname


class ActionItem(object):
    def __init__(self, list, code, what, project):
        self.list = list
        self.code = code
        self.what = what
        self.project = project

        actionlog.debug('Action for list "%s", from project %s', list,
                project)

        if not lists.has_key(self.list):
            lists[self.list] = []
        lists[self.list].append(self)
    def isUnfinished(self):
        return self.code in '@'
    def isFinished(self):
        return not self.isUnfinished()
    def __str__(self):
        return '%s [%s]' % (self.what, self.project.title)

class Project(object):
    log = logging.getLogger('project')
    def __init__(self):
        self.data = None
        self.title = ''
        self.fname = ''
        pass

    def readfile(self, fname, shortname):
        self.fname = fname
        self.shortname = shortname
        self.log.debug('reading %s', fname)

        self.lines = open(fname, 'r').readlines()
        try:
            self.title = self.lines[0][:-1].strip()
        except IndexError:
            self.log.error('%s has no first line!', shortname)
        self.check_actionlists()

    def __str__(self):
        return '%s (%s)' % (self.title, self.fname)

    def check_actionlists(self):
        for line in self.lines:
            m = actionmatcher.search(line)
            if m:
                l = m.group('list')
                what = m.group('what')
                code = m.group('code')

                what.strip()
                code.strip()

                ai = ActionItem(l, code, what, self)



def read_projects():
    base = os.path.expanduser(gtd_dir)
    base = os.path.expandvars(base)
    projs = []

    log = logging.getLogger('walker')

    log.debug('starting at %s', base)

    for root, dirs, files in os.walk(base):
        if '.bzr' in dirs:
            dirs.remove('.bzr')
        nonskipped = [ f for f in files if f[0] != '.' ]
        for f in nonskipped:
            log.debug('parse %s', os.path.join(root, f))
            p = Project()
            p.readfile(os.path.join(root, f), f)
            projs.append(p)

    return projs

def parse_cmdargs():
    parser = OptionParser()
    parser.add_option('-A', '--all', action='store_true', default=0,
            dest='use_all_categories', help='Also display waitfor, maybe, someday and defer categories')
    parser.add_option('-a', '--actions', action='store_true', default=0,
            dest='show_action', help='show actions on stdout')
    parser.add_option('-g', '--generate', action='store_true', default=0,
            dest='generate_html', help='unused')
    parser.add_option('-C', '--show-categories', action='store_true',
            default=0, dest='show_categories', help='Display available categories')
    parser.add_option('-n', '--show-numbers', action='store_true',
            default=0, dest='show_numbers', help='if displaying categories, write the number of entries in that category')
    parser.add_option('-v', '--verbose', action='store_true',
            default=0, dest='verbose')
    parser.add_option('-p', '--pdf', action='store_true',
            default=0, dest='dopdf', help='create a pdf file')
    parser.add_option('-d', '--debug', action='store_true',
            default=0, dest='debug', help='turn debugging output on.')
    parser.add_option('-P', '--print', action='store_true',
            default=0, dest='sendprinter', help='Send the generated pdf to the default printer.')
    parser.add_option('-c', '--category', action='store', dest='category',
            default='',help='limit output/pdf to specified category. For multiple categories, seperate them by a colon.')

    (option, args) = parser.parse_args()

    option.filename = 'gtdlist.pdf'

    return option, args

def draw_cutlines(canvas):
    canvas.setDash(1,8)
    p = canvas.beginPath()
    #p.setFillGray(0.6)
    p.moveTo(A4[0]/2, 0)
    p.lineTo(A4[0]/2, A4[1])

    p.moveTo(0, A4[1]/2)
    p.lineTo(A4[0], A4[1]/2)

    canvas.drawPath(p)

def print_output(op):
    flowlog.debug('print_output')

    gtdpdfprinter.print_actionlist(lists, op.filename)
    return

def filter_lists(options):
    global lists
    if not options.category:
        showcategories = lists.keys()
        if not options.use_all_categories:
            showcategories = [ s for s in showcategories if s not in
                    ('waitfor', 'maybe', 'someday', 'defer')]
        showcategories.sort()
    else:
        showcategories = options.category.split(':')

    categories = {}
    for s in showcategories:
        if s in lists.keys():
            l = [a for a in lists[s] if a.isUnfinished() or options.verbose]
            if l:
                categories[s] = l

    lists = categories



def main():
    op, args = parse_cmdargs()
    if op.debug:
        logging.getLogger().setLevel(logging.DEBUG)

    #print 'options', op
    #print 'args', args

    p = read_projects()

    filter_lists(op)
    if op.show_categories:
        k = lists.keys()
        k.sort()
        if op.show_numbers:
            for item in k:
                print item, len(lists[item])
        else:
            for l in wrap(', '.join(k)):
                print l

    if op.dopdf or op.sendprinter:
        print_output(op)
        if op.sendprinter:
            printFile(op.filename)
    if op.show_action:
        if not op.category:
            showcategories = lists.keys()
            showcategories = [ s for s in showcategories if s not in
                    ('waitfor', 'maybe', 'someday', 'defer')]
            showcategories.sort()
        else:
            showcategories = op.category.split(':')
        for k in showcategories:
            if not lists.has_key(k):
                print 'actionlist %s does not exist.' % (k,)
            else:
                namespace = {'actionlist': k, 'actions': lists[k] }
                try:
                    template1 = Template(simpleTemplate,
                            searchList=[namespace])
                    print template1
                except UserWarning:
                    pass

                if 0:

                    print k
                    for it in lists[k]:
                        if it.isUnfinished() or op.verbose:
                            out = str(it)
                            for l in wrap(out):
                                print '   ', l

if __name__ == '__main__':
    main()

